1. 설치

    1) React-router-dom
        npm i react-router-dom@5
        npm i --save-dev @types/react-router-dom@5   // 이게 타입스크립트

    2) react-redux
        npm install react-redux

    3) redux-toolkit
        npm install @reduxjs/toolkit

    4) react-transition-group
        npm i --save-dev @types/react-transition-group // 이게 타입스크립트꺼인듯

    5) react-animation-on-scroll
        npm install react-animation-on-scroll --save
        npm install --save animate.css

2. 우선 UI 부터 전부 작업 시작

    1) "mainpage 작업"
        Video

    2) "header footer 작업"

3. 스크롤 애니메이션 작업 완

4. MainPage UI 완료
    react-animation-on-scroll 과 react-transition-group 을 적절히 사용한다.

5. HOW-to-work Page 작성

    [일단 파츠(부위)별 컴포넌트를 전부 만든다.]

        "HowToWorkOut Page" 는
        "Choose Part 컴포넌트" , "Descripion 컴포넌트" 로 구성

        "Choose Part 컴포넌트" 는 기본적으로 "디폴트 Description" 이 같이 렌더
        "Choose Part 컴포넌트" 에서 "해당 부위의 버튼을 누르면"
        " 해당 부위의 Description"이 "렌더된다."

        [리덕스]를 이용하여, 리덕스를 이용하여, State 를 만들어서, 
            "Choose Part 컴포넌트"에서, 버튼을 누르면,  "HowToWorkOut Page" 에서, 받아, 다른 것을 렌더하는 형식으로 하자

        [ Descripion 이 바뀔때는, React-Transition-Group 을 사용하여]
            마치 슬라이드 되듯 넘어가는 화면을 구축해보자

                
        < 워크 플로우 >

            [HowToWorkOut Page]
                    |
                    |---- choose-parts.tsx          // 기본
                    |
                    |---- 0. default-description.tsx   // 기본 (버튼 선택 전까지)
                    |
                    |
                    |---- 1.chest-part-description  // 버튼선택시
                    |       * (0.all-parts-description.module.css) // css동일
                    |           |
                    |           |
                    |           ---- DesCard.tsx (동적 카드)
                    |       
                    |
                    |---- 2.back-part-description   // 버튼선택시
                    |       * (0.all-parts-description.module.css)  // css동일
                        ...

6. 변환 동작 구현 [ 총 코드 정리]

    [1. 리덕스툴킷 슬라이스 "store/choose-part-slice.tsx" ]

        import { createSlice } from "@reduxjs/toolkit";

        export type PartState = {       // 반드시 객체안에, 한번 담아서, 한번에 초기화가 가능하게 만든다.
            descriptionState: {         // State 를 reducer 에서 바로 사용하면 Proxy 가 생기는 오류가 발생한다.
                onDefaultPart: boolean;
                onChestPart: boolean;
                    ...
                onLegsPart: boolean;
                onGlutesPart: boolean;
            };
        };

        const initialState: PartState = {
            descriptionState: {
                onDefaultPart: true,
                onChestPart: false,
                    ...
                onLegsPart: false,
                onGlutesPart: false,
            },
        };

        const ChoosPartsSlice = createSlice({
            name: "choose-part",
            initialState,
            reducers: {
                ChestDescription(state) {
                    state.descriptionState = { ...initialState.descriptionState };  // State 를 바로 사용하지 않고, 한번 넣어 사용했기에 가능하다.
                    state.descriptionState.onDefaultPart = false;                   // 디폴트는 없애고
                    state.descriptionState.onChestPart = true;                      // 각각에 맞는 State 를 업데이트한다.
                },
                        ...
                LegsDescription(state) {
                    state.descriptionState = { ...initialState.descriptionState };
                    state.descriptionState.onDefaultPart = false;
                    state.descriptionState.onLegsPart = true;
                },
                GlutesDescription(state) {
                    state.descriptionState = { ...initialState.descriptionState };
                    state.descriptionState.onDefaultPart = false;
                    state.descriptionState.onGlutesPart = true;
                },
            },
        });

        export const ChooseActions = ChoosPartsSlice.actions;

        export default ChoosPartsSlice.reducer;

    [2. 스토어 생성 "store/index.tsx" ]
        import { configureStore } from "@reduxjs/toolkit";
        import choosePartSlice from "./choose-part-slice";

        export const store = configureStore({
            reducer: { choosePart: choosePartSlice },
        });

        export type RootState = ReturnType<typeof store.getState>;
        export type AppDispatch = typeof store.dispatch;

    [3. 스토어 등록 "index.tsx"]

        import ReactDOM from "react-dom/client";
        import "./index.css";
        import App from "./App";
        import { BrowserRouter } from "react-router-dom";
        import Layout from "./components/UI/layout/layout";
        import { Provider } from "react-redux";
        import { store } from "./store";

        const root = ReactDOM.createRoot(
        document.getElementById("root") as HTMLElement
        );
        root.render(
            <Provider store={store}>
                <BrowserRouter>
                <Layout>
                    <App />
                </Layout>
                </BrowserRouter>
            </Provider>
        );


    [4. 파트 선택 컴포넌트 "components/how-to-workout/choose-parts.tsx"]

        import styles from "./choose-parts.module.css";
        import { useCallback } from "react";
        import { useDispatch } from "react-redux";
        import { ChooseActions } from "../../store/choose-part-slice";

        const ChooseParts = () => {
            const dispatch = useDispatch();                     // dispatch 사용

            const onChestHandler = useCallback(() => {
                dispatch(ChooseActions.ChestDescription());     // useCallback 과 함께, actions, dispatch
            }, [dispatch]);
                        ...

            const onLegsHandler = useCallback(() => {
                dispatch(ChooseActions.LegsDescription());
            }, [dispatch]);
            const onGlutesHandler = useCallback(() => {
                dispatch(ChooseActions.GlutesDescription());
            }, [dispatch]);

            return (
                        ...

                <ul className={styles.select_parts}>
                    <li onClick={() => onChestHandler()}>       // 각각의 li 에 리스너 등록
                        <div className={styles.parts_text}>
                            <img src="/2.parts/torso.png" alt="torso" />
                            <p>가슴</p>
                        </div>
                        <div className={styles.parts_img}>
                            <img src="/2.parts/icons8-circled-right-100.png" alt="arrow" />
                        </div>
                    </li>
                            ...

                    <li onClick={() => onShoulderHandler()}>
                        <div className={styles.parts_text}>
                            <img src="/2.parts/shoulders.png" alt="back" />
                            <p>어깨</p>
                        </div>
                        <div className={styles.parts_img}>
                            <img src="/2.parts/icons8-circled-right-100.png" alt="arrow" />
                        </div>
                    </li>
                    <li onClick={() => onBicepsHandler()}>
                        <div className={styles.parts_text}>
                            <img src="/2.parts/biceps.png" alt="biceps" />
                            <p>이두</p>
                        </div>
                        <div className={styles.parts_img}>
                            <img src="/2.parts/icons8-circled-right-100.png" alt="arrow" />
                        </div>
                    </li>
                            ...

    [5. Page 에서, State 에 따라 다른 컴포넌트 렌더 "/pages/2.how-to-workout.jsx"]

        import ChooseParts from "../components/2.how-to-workout/choose-parts";
        import DefaultDes from "../components/2.how-to-workout/default-description";
        import ChestPartDes from "../components/2.how-to-workout/1.chest-part-description";
                        ...
        import LegsPartDes from "../components/2.how-to-workout/7.legs-part-description";
        import GlutesPartDes from "../components/2.how-to-workout/8.glutes-part-description";
   
        import { useSelector } from "react-redux";
        import { RootState } from "../store";

        const HowToWorkOut = () => {
            const chooseDescription = useSelector((state: RootState) => state.choosePart);  // state 를 빼서 사용

            return (
                <div>
                    <ChooseParts />
                    {chooseDescription.descriptionState.onDefaultPart && <DefaultDes />}
                    {chooseDescription.descriptionState.onChestPart && <ChestPartDes />}
                                ...
                    {chooseDescription.descriptionState.onLegsPart && <LegsPartDes />}
                    {chooseDescription.descriptionState.onGlutesPart && <GlutesPartDes />}
                </div>
            );
        };

        export default HowToWorkOut;

    [6. 렌더되는 Descripion "components/how-to-work-out/1.chest-part-description.tsx" ... 등]

            import DesCard from "../UI/descriptionCard/DesCard";        // 카드 아웃소싱
            import styles from "./0.all-parts-description.module.css";

            const ChestPartDes = () => {
                return (
                    <div className={styles.main_div}>
                        <DesCard
                            name={"벤치프레스"}
                            img={"/2.parts/do-parts/graham-mansfield-rkBkXqlfRRo-unsplash.jpg"}
                            des={[
                                { id: 1, text: "팔꿈치와 명치 사이의 수직 각도" },
                                { id: 2, text: "충분한 허리의 아치각도 유지하기" },
                            ]}
                            warn={[
                                { id: 1, text: "팔꿈치와 명치 사이의 수직 각도" },
                                { id: 2, text: "충분한 허리의 아치각도 유지하기" },
                            ]}
                        />
                    </div>
                );
            };

            export default ChestPartDes;

    [ 7. 실제로 화면에 보이는 [운동 방법 카드] "/components/UI/descriptionCard/DesCard.tsx"]

        import styles from "./DesCard.module.css";
        import { AnimationOnScroll } from "react-animation-on-scroll";

        export type Exr = {     // 타입 정하기
            name: string;
            img: string;
            des: { id: number; text: string }[];
            warn: { id: number; text: string }[];
        };

        const DesCard: React.FC<Exr> = (props) => {
            const { name, img, des, warn } = props;
            return (
                <div className={styles.main_card}>
                    <div className={styles.title_div}>
                        <p>{name}</p>
                    </div>

                    {/* Description Part */}

                    <div className={styles.main_desc_div}>
                        <ul className={styles.main_desc_text_ul}>
                            {des.map((item) => (
                                <li key={item.id}> {item.text}</li>
                            ))}
                        </ul>
                        <div className={styles.main_desc_img_div}>
                            <img src={img} alt={"img"}></img>
                        </div>
                    </div>

                    {/* Warning Part */}

                    <div className={styles.main_warning_div}>
                        <p> 유의사항</p>
                        <ul className={styles.main_warning_lists}>
                            {warn.map((item) => (
                                <AnimationOnScroll animateIn="animate__bounceIn" key={item.id}>     // 애니메이션 적용
                                    <li key={item.id}> {item.text}</li>
                                </AnimationOnScroll>
                            ))}
                        </ul>
                    </div>
                </div>
            );
        };

        export default DesCard;


7. 사진들 포토샵으로 용량 줄이기 완료

8. 소모 칼로리 페이지 시놉시스 정도 작성

9. 소모 칼로리 페이지 UI 작업 시작
    radio 버튼 사용해보았다.

10. 소모 칼로리 페이지, [계산 할 때마다 튀어오르는 애니메이션 버튼 만들기 with useEffect], 애니메이션 조절해보기(AnimatedCss 패키지 ), 로직 아웃소싱하기 

    < components / EstimateBMR.tsx > =============================================

        import { FormEvent, useEffect, useRef, useState } from "react";

        const EstimateBMR = () => {
            const [buttonStyle, setButtonStyle] = useState<string>(
                `${styles.answer_section_totalCal} animate__animated animate__bounce`       // 1. 시작은 바운스
            );                                                                              // ** module css와 global css 를 동시 사용


            useEffect(() => {
                setButtonStyle(
                `${styles.answer_section_totalCal} animate__animated animate__bounce`       // 2. 버튼스타일이 변경되면 바운스
                );
            }, [buttonStyle]);
            
            const justconsole = (event: FormEvent) => {
                event.preventDefault();
                setButtonStyle(`${styles.answer_section_totalCal}`);                        // 3. 제출하면, 바운스 제거
                            ...
            };

            return (
                        ...
                    <div>
                        <p className={styles.answer_section_textP}>
                            당신의 하루 소비 칼로리 량
                        </p>
                        <h1 className={buttonStyle}>{AMR} kcal</h1>     // 바운스 스타일
                    </div>

            );
        };

        export default EstimateBMR;

    <heper / calculate-logic.tsx > =============================================

        export const CalculateFunction = ( sex: number, age: number, weight: number, tall: number, activity: number ) => {
            let BMR;

            if (sex === 1) {
                BMR = 88.4 + 13.4 * weight + 4.8 * tall - 5.68 * age;
            } else {
                BMR = 447.6 + 9.25 * weight + 3.1 * tall - 4.33 * age;
            }
            const finalAMR = BMR * activity;

            return finalAMR;
        };


    <index.css> ============================================================

        /*  애니메이션  */

        .animate__animated.animate__bounce {        // 하나하나 조절
            --animate-delay: 0.1s;
            --animate-duration: 700ms;
        }

        :root {     // 전부 조절

        }

11. 칼로리 소모 페이지 UI 작업 끝

12. 길게 hr 만들었는데, 화면을 튀어나가버린다. 어떻게하지?

    ==> 그린 라인을 씌우는 div 를 만들어서 overflow를 넣는다.

        /* 크로스 라인  Green-rotate */

                .cross_line_green_rotate {
                    position: relative;
                    background-color: var(--loss-weight-parts-intro-background-color);
                    height: 3rem;
                    margin: 1.5rem 0;
                    border: none;
                    z-index: 2;
                    opacity: 0.8;
                    transform: rotate(-5deg);
                    width: 110%;
                    margin-left: -2rem;
                }


        // 크로스 그린 라인 div  [ 여러개의 크로스 라인 포함된 div ]

                .cross_line_div {
                    width: 100%;
                    overflow: hidden;
                    height: 20rem;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                }


13. 식단 알아보기 페이지 작업 시작


14. [ 데이터를 넣으면 자동으로 Card 가 만들어지는 페이지 작성]  식단 알아보기 페이지에서, 

    1) "FoodCard 작성"

        < UI / foodsCard / food-previewcard.tsx >

            import styles from "./food-previewcard.module.css";

            const FoodPreview: React.FC<{                       // 받아올 값들, 타입 지정
                id: number;
                img:string;
                category: string;
                title: string;
                majorNutri: string;
                nutri: string;
                price: number;
            }> = (props) => {
            const { id, img, category, title, majorNutri, nutri, price } = props;    // 받아올 값들

                return (
                    <div className={styles.main_div}>
                        <section className={styles.img_section}>
                            <img src={img} />                       // 이미지
                            <div className={styles.img_section_category}> {category}</div>  // 카테고리
                        </section>
                        <section className={styles.info_section}>
                            <div className={styles.info_section_title}>
                                <p> {title}</p>     // 타이틀
                            </div>
                            <div className={styles.info_section_info_detail}>
                                <div className={styles.info_section_info_detail_category}>
                                    {majorNutri}        // 메이저뉴트리
                                </div>
                                <div className={styles.info_section_info_detail_nutri_price}>
                                    <p> {nutri}</p>     // 뉴트리
                                    <p> {price}</p>     // 가격
                                </div>
                            </div>
                        </section>
                    </div>
                );
            };

            export default FoodPreview;

    2) "ListData 를 넘겨준다."

        < components / 4.find-foods / 1.Foods-List.tsx >

            import FoodPreview from "../UI/foodsCard/food-previewcard";
            import { useState } from "react";
            
            interface FoodType {        // 넘겨줄 FoodType 지정
                id: number;
                img:string;
                category: string;
                title: string;
                majorNutri: string;
                nutri: string;
                price: number;
            }
            
            const FoodsList = () => {        // 추후 FireBase DB 에서 fetch 해서 가져오도록 하자. 일단 샘플 데이터 두개
                                            // 또한, 자동 Grid 를 통해, 자동 Grid 조정을 하게 만든다. (블로그참조)

            const [foodsData, setFoodsData] = useState<FoodType[]>([        // "타입 지정 후" 일단 더미데이터 두개만 집어넣었다.
                {
                    id: 1,
                    category: "다이어트",
                    img:"/4.foods/claudio-schwarz-4qJlXK4mYzU-unsplash.jpg",
                    title: "최고의 단백질 보충제 닭가슴살",
                    majorNutri: "단백질+",
                    nutri: "Protein 22g",
                    price: 1000,
                },
                {
                    id: 2,
                    category: "벌크업",
                    img:"/4.foods/claudio-schwarz-4qJlXK4mYzU-unsplash.jpg",
                    title: "최고의 지방 보충제 아보카도",
                    majorNutri: "지방+",
                    nutri: "Fat 15g",
                    price: 2000,
                },
                ]);

                return (
                    <div>
                        {foodsData.map((food) => (          // Array.map() 을 통해, 모든 데이터를 한번에 넘기도록 한다.
                            <FoodPreview
                                key={food.id}
                                id={food.id}
                                img={food.img}
                                category={food.category}
                                title={food.title}
                                majorNutri={food.majorNutri}
                                nutri={food.nutri}
                                price={food.price}
                            />
                        ))}
                    </div>
                );
            };
            export default FoodsList;
            
    3) 자동 Grid 형태의 CSS 작성

        .main_grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(27rem, 1fr));
        }
        
    4) 우측에 div 위치 calc 를 통해, 잘 조절

        .select_category {
            margin-left: calc(100% - 27rem);

    * 그냥 65% 따위로 하면, div 의 width 때문에, 줄이면 넘어간다.

15. 버튼 누르면 [ 양옆으로 하이라이트가 부드럽게 움직이는 ] 셀렉터 만들기

    < 컴포넌트 >
  
        const FoodsList = () => {
        
            const [selected, setSelected] = useState<string>("탄수화물");
            const [foodsData, setFoodsData] = useState<FoodType[]>([
            {
                id: 1,
                        ...
                price: 1000,
            },
            {
                id: 2,
                        ...
            }
            ]);
        
            let selected_style = styles.selected_hydro;     // 초기 하이라이트 백그라운드 조건
            let text_highlight_hydro = "";                  // 초기 텍스트 조건
            let text_highlight_protein = "";                // 초기 텍스트 조건
            let text_highlight_fat = "";                    // 초기 텍스트 조건
        
            if (selected === "탄수화물") {
                selected_style = styles.selected_hydro;                 // 선택시 클래스 변경 (하나의 div 좌우로 움직임)
                text_highlight_hydro = styles.selected_text_hydro;      // 선택시 해당 클래스 이름 생성 ( 각각이 선택되면 각각에서 따로 켜짐 )
            }
            if (selected === "단백질") {
                selected_style = styles.selected_protein;
                text_highlight_protein = styles.selected_text_protein;
            }
            if (selected === "지방") {
                selected_style = styles.selected_fat;
                text_highlight_fat = styles.selected_text_fat;
            }
            return (
                <div className={styles.main_div}>
                    <ul className={styles.select_category}>
                
                        <div className={selected_style}></div>                  // 움직이는 백그라운드 div 

                        <li onClick={() => setSelected("탄수화물")}>
                            <p className={text_highlight_hydro}>탄수화물</p>    // 선택되면 적절한 className 이 켜진다.
                        </li>
                        <li onClick={() => setSelected("단백질")}>
                            <p className={text_highlight_protein}>단백질</p>
                        </li>
                        <li onClick={() => setSelected("지방")}>
                            <p className={text_highlight_fat}>지방</p>
                        </li>
                    </ul>
    < CSS >

            /* 하이라이트 Div 조건1 - 탄수화물  */
            .selected_hydro {
                position: absolute;
                width: 8rem;
                height: 2.5rem;
                z-index: 1;
                background-color: white;
                margin-right: 18rem;
                border-radius: 5px;
                transition: all 400ms ease-out;
                box-shadow: 1px 1px 4px black;
            }

            /* 하이라이트 Text 조건1 - 탄수화물  */
            .selected_text_hydro {
                font-weight: 600;
                font-size: 1.1rem;
                transition: all 600ms ease-out;
            }

            /* 하이라이트 Div 조건2 - 단백질  */
            .selected_protein {
                position: absolute;
                width: 8rem;
                height: 2.5rem;
                z-index: 1;
                background-color: white;
                border-radius: 5px;
                transition: all 400ms ease-out;
                box-shadow: 1px 1px 4px black;
            }

            /* 하이라이트 Text 조건2 - 단백질  */
            .selected_text_protein {
                font-weight: 600;
                font-size: 1.1rem;
                transition: all 600ms ease-out;
            }

            /* 하이라이트 Div 조건3 - 지방  */
            .selected_fat {
                position: absolute;
                width: 8rem;
                height: 2.5rem;
                z-index: 1;
                background-color: white;
                margin-left: 18rem;
                border-radius: 5px;
                transition: all 400ms ease-out;
                box-shadow: 1px 1px 4px black;
            }

            /* 하이라이트 Text 조건3 - 지방  */
            .selected_text_fat {
                font-weight: 600;
                font-size: 1.1rem;
                transition: all 600ms ease-out;
            }

16. 선택한 Selected 를 바탕으로 [선택된 Data 만 따로 화면에 띄우기]


        const [selected, setSelected] = useState<string>("탄수화물");
        const [foodsData, setFoodsData] = useState<FoodType[]>([
            {
                id: 1,
                        ...
                price: 1000,
            },
            {
                id: 2,
                        ...
            },
        ]);

        const [selectedFoods, setSelectedFoods] = useState<FoodType[]>([]);   // filter 될 FoodData

        useEffect(() => {       // filter 되는 로직
            setSelectedFoods(foodsData.filter((food) => food.majorNutri === selected));
        }, [selected]);

        return (
            <div className={styles.main_grid}>
                {selectedFoods.map((food) => (      // "selectedFoods" 로 Data 변경
                    <FoodPreview
                    key={food.id}
                    id={food.id}
                        ...
                    )


    ** 반드시 useEffect 를 사용하도록 하자.
    ** "추후 데이터"는, "FireBase" 에서 온 것을 "App.tsx" 에서 받아서, "리덕스 툴킷" 으로 넘긴 다음, 사용 할 것이다.

17. 파이어베이스로 DB 만들기 

    1) 운동방법

        [how-to-workout Page] -> [8개의 부위 Component 들] -> [각 Item은 DesCard 에 데이터]

        DB "exercise"
            // part : chest, back, shoulders, biceps, triceps, abs, legs, glutes
            //  part, name, img, des:[id, text], warn:[id,text]
            [ {part:chest, name:체스트프레스, img:"...", 
                des  : [{text:"..."}, { text:"..."}], 
                warn : [{text:"..."}, { text:"..."}],
              },
              {part:back, name:풀업, img:"...", 
                des  : [{text:"..."}, {text:"..."}], 
                warn : [{text:"..."}, { text:"..."}],
              },
              {part:triceps, name:킥백, img:"...", 
                des  : [{text:"..."}, { text:"..."}], 
                warn : [{ text:"..."}, {text:"..."}],
              },
            
            ]

    2) 음식 리스트

        DB "foods"
            category : 다이어트, 벌크업, 린매스업
            name : xxxxxx, 닭가슴살
            majorNutri : 단백질, 지방, 탄수화물
            id : f1, f2 ...
            nutri : 지방 15g ...
            price : 1000 ...
            id / img / category / title / majorNutri / nutri / price

[17-1. 파이어베이스에 마이그레이션 하는게, 너무 힘들어서, 페이지만든다.]

    < component >

    // 아이디 :  e1, e2 ...
    // 파트 : chest, back, shoulders, biceps, triceps, abs, legs, glutes
    // des : [{id:1, text:"..."}, {id:2, text:"..."}]
    // warn : [{id:1, text:"..."}, {id:2, text:"..."}]

        import { FormEvent, useState, useRef } from "react";
        import styles from "./add-exercise.module.css";
        import { postExercise } from "../../helper/add-exercise-fetch";

        const AddExercise = () => {
            const desTextRef = useRef<HTMLInputElement>(null);
            const warnTextRef = useRef<HTMLInputElement>(null);

            const [id, setId] = useState<string>("");
                        ...
            const [warn, setWarn] = useState<{ text: string }[]>([]);

            const AddDes = (event: FormEvent) => {              // description Array 추가
                event.preventDefault();
                const desText = desTextRef.current!.value;

                setDes([...des, { text: desText }]);

                desTextRef.current!.value = "";
            };

            const AddWarn = (event: FormEvent) => {             // warning Array 추가
                event.preventDefault();
                const warnText = warnTextRef.current!.value;

                setWarn([...warn, { text: warnText }]);

                warnTextRef.current!.value = "";
            };

            const submitHandler = async (event: FormEvent) => {     // fetch 시작
                event.preventDefault();

                const exerciseData = { id, part, name, img, des, warn };    // fetch 할 데이터
                await postExercise(exerciseData);                // "fetch 아웃소싱"
                setId(() => "");                                // 초기화
                        ...
                setDes(() => []);
                setWarn(() => []);
            };

            return (
                <div className={styles.main_div}>
                    <form onSubmit={submitHandler}>
                        <div>
                            <label htmlFor="id"> 아이디 </label>
                            <input
                                placeholder="e1,e2..."
                                    ...
                            <label htmlFor="name"> 운동이름 </label>
                            <input
                                placeholder="벤치 프레스, 킥 백, 숄더 프레스..."
                                type={"text"}
                                id="name"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                            />
                        </div>
                                ...
                        <div>
                            <label htmlFor="des"> 설명 </label>
                                    ...
                            <label htmlFor="warn"> 유의사항 </label>
                                <input
                                    placeholder="1.xxx, 2.xxx ..."
                                    type={"text"}
                                    id="warn"
                                    ref={warnTextRef}
                                    style={{ width: "25rem" }}
                                />
                                {warn.map((item) => (
                                    <p key={item.text}>{item.text}</p>
                                ))}
                                <button onClick={AddWarn}> 추가 </button>
                        </div>
                        <div>
                            <button> 제출</button>
                        </div>
                    </form>
                </div>
            );
        };

        export default AddExercise;

    <helper - fetch>

        export type PostType = {
            id: string;
            part: string;
            name: string;
            img: string;
            des: {text: string }[];
            warn: {text: string }[];
        };
        
        export const postExercise = async (exerciseData: PostType) => {
            await fetch("https://do-health-project-default-rtdb.firebaseio.com/exercise.json", {
                method: "POST",
                body: JSON.stringify(exerciseData),
                headers: {
                    "Content-Type": "application/json",
                },
            });
        };
        

18. fetch 하여, DB 에서 데이터 가져오기 [Thunk 액션생성자 사용, State 에 집어넣기,  FireBase 에서 data 가져오기 with 타입스크립트, FireBase Data 재가공]

    ** KeyPoint
        [1. 리덕스 툴킷에서, 비동기 함수를 사용하기 위한, Thunk Action 생성자의 생성 ( Slice 의 Reducer action 은 반드시 순수함수 이므로) ]
        [2. Thunk Action 생성자를 생성할때, "타입지정" 과 useDispatch 의 생성 방법] ***
        [3. Thunk Action 생성자를 사용할때, 미리 정의한 AppDispatch 를 사용하는 것]


    0. 파이어베이스에서 온 Data 재가공 (Array 형태가 아닌, object 로 감싼형태로 오므로)

        <helper / fetch-get-exercise.tsx >
            : 사용 할 것은 아니지만, 전반적인 기능만 보았다.

                export const getExercise = async () => {
                    const response = await fetch(
                    "https://do-health-project-default-rtdb.firebaseio.com/exercise.json"
                    );
                
                    const responseData = await response.json();
                
                    const refineData = [];                  // 데이터 재가공
                
                    for (const key in responseData) {       // 데이터 재가공
                        refineData.push({
                            id: responseData[key].id,
                            img: responseData[key].img,
                            name: responseData[key].name,
                            part: responseData[key].part,
                            des: responseData[key].des,
                            warn: responseData[key].warn,
                        });
                    }
                
                    console.log(refineData);
                
                    return responseData;
                };
            
                
       < 가공 후 데이터 형태 >
            id: "e1"
            img: "/2.parts/do-parts/chest/pexels-andrea-piacquadio-3837781.jpg"
            name: "벤치 프레스"
            part: "chest"
            des : (5) [{…}, {…}, {…}, {…}, {…}]
                    0 : {text: ...}, 1: {text:...}
            warn: (3) [{…}, {…}, {…}]
                    0 : {text: ...}, 1: {text:...}


    1. 가공 데이터를 토대로 exercise Data 를 담을 Slide 생성

        <store / exercise-slice.tsx >

            [가공 후데이터 형태]
            //      id: "e1"
            //      img: "/2.parts/do-parts/chest/pexels-andrea-piacquadio-3837781.jpg"
            //      name: "벤치 프레스"
            //      part: "chest"
            //      des : (5) [{…}, {…}, {…}, {…}, {…}]
            //              0 : {text: ...}, 1: {text:...}
            //      warn: (3) [{…}, {…}, {…}]
            //              0 : {text: ...}, 1: {text:...}

            import { createSlice, PayloadAction } from "@reduxjs/toolkit";

            export interface ExerciseType {
                id: string;
                img: string;
                name: string;
                part: string;
                des: { text: string }[];
                warn: { text: string }[];
            }

            const initialState: { exerciseData: ExerciseType[] } = {     // exerciseData 안에, Data 들을 전부 넣을 것이다.
                exerciseData: [],
            };

            const exerciseSlice = createSlice({
                name: "exercise",
                initialState,
                reducers: {
                    updateAllExercise(state, action: PayloadAction<ExerciseType[]>) {
                        state.exerciseData = action.payload;                // payload 에서 오는 값을, exerciseData 로 교체할 것이다.
                    },
                },
            });

            export const exerciseActions = exerciseSlice.actions;

            export default exerciseSlice.reducer;



    2. [ Thunk Action 생성자 이용한, "비동기함수(fetch)"의 사용 - Store 에 State 담기, ** useAppDispatch의 생성 ] 

-       1. Dispatch 의 타입 지정
-       2. Thunk action 생성자 사용시에 필요한 Dispath 를 export
            https://redux.js.org/tutorials/typescript-quick-start#define-typed-hooks
        

        < store / exercise-action.tsx >

            import { Dispatch } from "@reduxjs/toolkit";
            import { exerciseActions } from "./exercise-slice";
            import { useDispatch } from "react-redux";              // useDispath 의 사전 생성
            import type { AppDispatch } from "../store/index";      //  action 생성자용 Dispatch
           

            export const sendRequest = () => {
                return async (dispatch: Dispatch) => {      // 1. 타입은 Dispatch 이다.
                   
                    const fetchData = async () => {         // 비동기 함수(fetch) 만들어서
                    
                        const response = await fetch(      
                            "https://do-health-project-default-rtdb.firebaseio.com/exercise.json"
                        );
                        const responseData = await response.json();

                        const refineData = [];              // 파이어 베이스에서 데이터 것 refine

                        for (const key in responseData) {
                            refineData.push({
                            id: responseData[key].id,
                            img: responseData[key].img,
                            name: responseData[key].name,
                            part: responseData[key].part,
                            des: responseData[key].des,
                            warn: responseData[key].warn,
                            });
                        }

                        return refineData;
                    };

                    const allExercise = await fetchData();

                    dispatch(exerciseActions.updateAllExercise(allExercise));   // inputData를 집어넣는 action 을 한다.
                };
            };

            export const useAppDispatch: () => AppDispatch = useDispatch;       // 2. Thunk action 생성자 사용시에 필요한 Dispath 를 export


    3. Thunk Action 생성자 사용 [ 정의한 useAppDispatch 사용 ]

-       : useDispatch 가 아닌,  "exercise-action.tsx" 에서 정의한 "useAppDispatch" 를 사용

        < App.tsx >

            import { sendRequest, useAppDispatch } from "./store/exercise-action";
            import { useEffect } from "react";
            import { useSelector } from "react-redux";
            import { RootState } from "./store";

            function App() {
                const exerciseState = useSelector(      // 확인용, State 뽑아보았다.
                    (state: RootState) => state.exercise.exerciseData
                );
            
                const dispatch = useAppDispatch();      // useDispatch 가 아닌, 정의한 useAppDispatch 사용

                useEffect(() => {
                    dispatch(sendRequest());            // useDispatch 가 아닌, 정의한 useAppDispatch 사용2
                }, [dispatch]);
            
                console.log(exerciseState);
            
                return (
                    <div className="App">
                        <Switch>
                        <Route path="/" exact>
                            <MainPage />
                            ...



        ** console.log(exerciseState)       // 확인 완료
            (20)[{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
           

    4. fetch 한 데이터로 교체

        <components / 2.how-to-workout / 1.chest-part-description.tsx >
            import DesCard from "../UI/descriptionCard/DesCard";
            import styles from "./0.all-parts-description.module.css";
            import { useSelector } from "react-redux";
            import { RootState } from "../../store";

            const ChestPartDes = () => {
                const exerciseData = useSelector(
                    (state: RootState) => state.exercise.exerciseData           // 데이터 뽑아서 사용
                );
                const filterdData = exerciseData.filter((item) => item.part === "chest");       // 필터

                return (
                    <div className={styles.main_div}>
                        {filterdData.map((item) => (
                            <DesCard
                                key={item.id}
                                name={item.name}
                                img={item.img}
                                des={item.des}
                                warn={item.warn}
                            ></DesCard>
                        ))}
                    </div>
                );
            };

            export default ChestPartDes;


19. food 도 똑같이 "마이그레이션 후 fetch 하여 DB 가져오기"

20. food 마이그레이션, fetch 완료

21. 런닝, 헬스, 수영, 헬스, 이미지 교체

22. 로그인 작업 시작 [ Email/ password]

    파이어베이스 auth
        https://firebase.google.com/docs/reference/rest/auth?hl=en&authuser=0#section-create-email-password

23. ".env" 를 통해, github 에 올라가는 것을 방지하고, 유저들에게 안보이게 만든다.

    1. npm i dotenv
    2. .env 파일을 root 디렉토리에 만든다.
    3. 안에 "반드시" REACT_APP_ 으로 시작하는 이름으로 값을 만든다.

        ex) REACT_APP_FIREBASE_API_KEY=asdasdasdasfdasdas

        ** "", ; 등의 기호를 사용하지 않음에 주의

    4. 사용한다.

        const API_KEY = process.env.REACT_APP_FIREBASE_API_KEY;
        console.log(API_KEY);

24. 회원가입 헬퍼 함수 만들기

    <helper / signup.tsx >

        export const signupHandler = async (email: string, password: string) => {
            const sendRequest = await fetch(
            `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${process.env.REACT_APP_FIREBASE_API_KEY}`,
            {
                method: "POST",
                body: JSON.stringify({ email, password, returnSecureToken: true }),
                headers: {
                "Content-Type": "application/json",
                },
            }
            );
            const responseData = await sendRequest.json();
        
            return responseData;        // 반드시 헬퍼함수에서, return 해야한다.
        };
      

    ** 계속해서, 헬퍼함수 내에서 return 을 하지 않아서, response 를 받지 못하는 어처구니 없는 실수를 반복하고 있다.
    ** 꼭 retrun 하여, 밖에서 사용하도록 만들자.

25. 회원가입 폼 만들기

    < components / 5.sign-up / signup-form.tsx >
    
        import styles from "./signup-form.module.css";
        import { signupHandler } from "../../helper/signup-handler";
        import { useRef, FormEvent } from "react";

        const SignUpForm = () => {
            const emailRef = useRef<HTMLInputElement>(null);
            const passwordRef = useRef<HTMLInputElement>(null);

            const submitHanlder = async (e: FormEvent) => {
                e.preventDefault();
                const email = emailRef.current!.value;
                const password = passwordRef.current!.value;

                const responseData = await signupHandler(email, password);

                console.log(responseData);
            };

            return (
                <div className={styles.main_div}>
                    <form onSubmit={submitHanlder}>
                        <div>
                            <label> 이메일을 입력하세요</label>
                            <input type={"email"} ref={emailRef} />
                        </div>
                        <div>
                            <label> 비밀번호를 입력하세요</label>
                            <input type={"password"} ref={passwordRef} />
                        </div>
                        <div>
                            <button> 제출</button>
                        </div>
                    </form>
                </div>
            );
        };

        export default SignUpForm;

                
26. 로그인도 똑같이 만든다. (헬퍼함수 + 폼)

[로그인 추가]
사용자들에게, 잘못된 로그인이거나, 잘못된 회원가입 정보를 받았을 경우, 화면에 표시해준다.

:" 파이어베이스는, 잘못된 정보를 입력하면, error 를 리턴해줍니다."

        import styles from "./signup-form.module.css";
        import { signupHandler } from "../../helper/signup-handler";
        import { useRef, FormEvent, useState } from "react";
        import { useHistory } from "react-router-dom";

        const SignUpForm = () => {
            const history = useHistory();
            const emailRef = useRef<HTMLInputElement>(null);
            const passwordRef = useRef<HTMLInputElement>(null);
            const [error, setError] = useState<string>("");

            const submitHanlder = async (e: FormEvent) => {
                e.preventDefault();
                const email = emailRef.current!.value;
                const password = passwordRef.current!.value;

                const responseData = await signupHandler(email, password);

                if (responseData.idToken) {
                    history.replace("/");
                } else if (responseData.error.message === "EMAIL_EXISTS") {
                    setError("이미 존재하는 이메일 입니다.");
                } else if ( responseData.error?.message === "WEAK_PASSWORD : Password should be at least 6 characters") {
                    setError("패스워드가 6자리 이하입니다.");
                }
            };
            return (
                <div className={styles.main_div}>
                        ...
                    <form 3onSubmit={submitHanlder} className={styles.signup_form}>
                        {error && <p className={styles.error}> {error}</p>}
                        <div>
                            <label> 이메일을 입력해주세요</label>
                            <input type={"email"} ref={emailRef} required />
                        </div>
                        <div>
                            <label> 비밀번호를 입력해주세요</label>
                            <input type={"password"} ref={passwordRef} required />
                        </div>
                        <div className={styles.button_div}>
                            <button className="Just_Click_Button_Default"> 제출</button>
                        </div>
                    </form>
                </div>
            );
        };

        export default SignUpForm;


27. react-cookie 를 이용하여, 로그인상태를 유지시킨다. 로그아웃 버튼을 만든다.

    1. 쿠키 프로바이더 감싸기

        < index.tsx >

            import { CookiesProvider } from "react-cookie";

            const root = ReactDOM.createRoot(
                document.getElementById("root") as HTMLElement
            );
                root.render(
                <CookiesProvider>
                    <Provider store={store}>
                        <BrowserRouter>
                            <Layout>
                                <App />
                            </Layout>
                        </BrowserRouter>
                    </Provider>
                </CookiesProvider>
            );

    2. 로그인 컴포넌트에서, 로그인하면 쿠키에 등록

        < components / SignInForm.tsx >

            import { useCookies } from "react-cookie";      // 쿠키 import 
            import { useHistory } from "react-router-dom";

            const SignInForm = () => {
                const history = useHistory();
                const [cookies, setCookie] = useCookies(["auth-cookie"]);
                const emailRef = useRef<HTMLInputElement>(null);
                const passwordRef = useRef<HTMLInputElement>(null);

                const submitHanlder = async (e: FormEvent) => {
                    e.preventDefault();
                    const email = emailRef.current!.value;
                    const password = passwordRef.current!.value;

                    const responseData = await signinHandler(email, password);

                    if (responseData.idToken) {    
                        setCookie("auth-cookie", responseData.idToken);     // 있다면 쿠키에 등록
                        history.replace("/");                               // 등록 후, 페이지 변경
                    }
                };

                return (
                    <div className={styles.main_div}>
                    <form onSubmit={submitHanlder}>
                        ...

    3. Layout 에서 로그인되어있다면, 회원가입, 로그인 버튼 없애기, 로그아웃 구현

            import styles from "./layout-header.module.css";
            import { Link } from "react-router-dom";
            import { useCookies } from "react-cookie";
            import { useHistory } from "react-router-dom";

            const LayoutHeader = () => {
                const [cookies, setCookie, removeCookie] = useCookies(["auth-cookie"]);     // 쿠키
                const history = useHistory();

                const logoutHandler = () => {
                    removeCookie("auth-cookie");
                    history.replace("/");
                };

                return (
                    <div className={styles.main_header}>
                        <Link to="/" className={styles.header_logo}>
                            <img src="/main-logo.png" alt="logo" />
                            <h3> DO.HEALTH</h3>
                        </Link>
                        <ul className={styles.header_menu}>

                            {!cookies["auth-cookie"] && (       // 쿠키 없다면, "활성화"
                            <Link to="/sign-up">
                                <li> 회원가입</li>
                            </Link>
                            )}

                            {!cookies["auth-cookie"] && (       // 쿠키 없다면, "활성화"
                            <Link to="/sign-in">
                                <li> 로그인</li>
                            </Link>
                            )}

                            {cookies["auth-cookie"] && <li onClick={logoutHandler}> 로그아웃</li>}  // 쿠키 있다면, "활성화"
                        </ul>
                    </div>
                );
            };

            export default LayoutHeader;

28. 자 이제, [일단 CSS, 기능들, 기타 이상한 것들] 총 정리하여 수정한다.

29. [내정보] 페이지 만들어서, [ 찜 한 운동 보이기 ] 만들어준다.   // 기능이 별로... 만들지 말자.
    
        # 0. 운동 방법 카드에, "찜하기" 를 만든다.

        # 1. "찜" 하면, "email과 함께", "운동 방법의 id" 를 DB에 함께 저장한다.
        #     [ email: test@test.com, favorite:["e1" , "e2", "e5" ...]]

        # 2. "내정보 페이지" 에서 "찜" 항목을 누르면, "찜 한 운동" 이 쭉 나오게 만든다.
        
        # 3. 찜 한 운동은, 카드 형식으로 짧게 만든다 ( 음식들 dp한 것 처럼 ).

    ** 취소

30. [CSS 수정] 및 [애니메이션 수정]

31. 미디어쿼리 수정
   [ width 1200px]

    1) 메인, 인트로 쿼리 수정

    2) 레이아웃 헤더 모바일용 생성- 미디어 쿼리에서, 변경될때, 나오도록

    3) 레이아웃 바텀 처리

    4) 모바일 식 햄버거버거 버튼의 활용

        "메뉴가 우측에서 삭 나온다."
        "메뉴는 언제나 존재하고, 대신 클래스이름을 변경시킴으로써, 바뀌도록 만든다."
        "햄버거 버튼을 누르면, State 가 변경되고, ClassName 이 변경되어, open 하게 만든다."
        "숨겨져 있는 메뉴는 앱 최상단에 존재한다."

            
            < layout.tsx >

                import styles from "./layout.module.css";
                import LayoutHeader from "./layout-header";
                import LayoutHeaderForM from "./layout-header-for-mobile";
                import LayoutFooter from "./layoute-footer";
                import LayoutHeaderModalForM from "./layout-header-for-mobile-modal";
                import { useState } from "react";

                const Layout: React.FC<{ children: React.ReactNode }> = (props) => {
                    const [showModal, setShowModal] = useState<boolean>(false);

                    const toggleModal = () => {
                        setShowModal((prev) => !prev);      // show State 생성
                    };

                    let showStyle;

                    if (showModal) {
                        showStyle = styles.show;            // state 별 다른, className 지정
                    }
                    if (!showModal) {
                        showStyle = styles.hide;
                    }

                    return (
                        <div>
                            <div className={styles.desk}>
                                <LayoutHeader />
                            </div>
                            <div className={styles.mobile}>
                                <LayoutHeaderForM toggleModal={toggleModal} />
                                <div className={showStyle}>         // 그에 따른 State [ hide or show ]
                                    <LayoutHeaderModalForM toggleModal={toggleModal} />
                                </div>
                            </div>
                            {props.children}
                            <LayoutFooter />
                        </div>
                    );
                };


                export default Layout;

        < layout-header-for-mobile.tsx >

            import styles from "./layout-header-for-mobile.module.css";
            import { Link } from "react-router-dom";

            const LayoutHeaderForM: React.FC<{ toggleModal: () => void }> = (props) => {
            const { toggleModal } = props;
                return (
                    <div className={styles.main_header}>
                        <Link to="/" className={styles.header_logo}>
                            <img src="/main-logo.png" alt="logo" />
                            <h3> DO.HEALTH</h3>
                        </Link>
                        <div className={styles.hamburger_button} onClick={toggleModal}>
                            <img src="/icons8-hamburger-64.png" />
                        </div>
                    </div>
                );
            };

            export default LayoutHeaderForM;

        < Modal.tsx >

            import styles from "./layout-header-for-mobile-modal.module.css";
            import { Link } from "react-router-dom";
            import { useCookies } from "react-cookie";
            import { useHistory } from "react-router-dom";

            const LayoutHeaderModalForM: React.FC<{ toggleModal: () => void }> = (
                props
            ) => {
                    
                const [cookies, setCookie, removeCookie] = useCookies(["auth-cookie"]);
                const { toggleModal } = props;
                const history = useHistory();

                const logoutHandler = () => {
                    removeCookie("auth-cookie");
                    toggleModal();
                    history.replace("/");
                };

                return (
                    <div className={styles.main_header}>
                        <div className={styles.logo_and_X}>
                            <div>
                                ...
                            )}
                            {cookies["auth-cookie"] && <li onClick={logoutHandler}>로그아웃</li>}
                        </ul>
                    </div>
                );
            };

            export default LayoutHeaderModalForM;


    5) 헬스 파트 미디어쿼리 수정
    6) 체중 파트 미디어쿼리 수정
    7) 식단 파트 미디어쿼리 수정
    8) 로그인, 로그아웃 페이지 수정


32. 코드점검 및 최적화

    1. "레이지로딩"과 "지연로딩"을 이용한 최적화를 하려 했으나 "레이지로딩"을 추가할 만한 쓰지 않는 페이지가 없었다.
    2. 이미지 크기 줄이기 [ OK ]
    3. 긴 라우터가 존재하지 않아서, React.memo 를 사용하지 않았다.
    4. 이상한 주소 들어가면 notfound 페이지 만들기
    

33. 배포

    배포시작


=============================== [ 추가 업데이트 사항 ]==============================================================

[내 정보] 페이지에, 달력 API 를 심어서, "내가 먹은 식단 정리" 페이지도 만들어본다.

1. 달력 API : 풀 캘린더(fullcalendar)

    리액트 DOCS : https://fullcalendar.io/docs/react
    리액트 EXAMPLE : https://stackblitz.com/github/fullcalendar/fullcalendar-examples/tree/main/react?file=src%2Fevent-utils.js,src%2FDemoApp.jsx
    타입스크립트 DOCS : https://github.com/fullcalendar/fullcalendar-examples/tree/main/react-typescript/src

    ** 일단 타입스크립트 EXAMPLE 을 전부 가져왔다
        DemoApp.jsx
        index.css
        event-utils.js 


[오류발생]

    : "confirm" 이 esLint 오류가 난다.
    :  앞에 "window" 를 붙여서 해결했다.
    
    handleEventClick = (clickInfo: EventClickArg) => {
        if (
            window.confirm(                     // window 를 앞에 붙였다.
                `Are you sure you want to delete the event '${clickInfo.event.title}'`
            )
        ) {
            clickInfo.event.remove();
        }



2. 데이터를 넣는 구조를 파악하여, DB에 어떻게 넣을지 고민하자

    [데이터 구성] -  "event-utils.js" 에서 확인

        let todayStr = new Date().toISOString().replace(/T.*$/, ""); // YYYY-MM-DD of today

        {
            id: createEventId(),        // 이건 고정시키고
            title: "All-day event",     // "타이틀"
            start: todayStr,            // 이건 시간
        },

    [ 데이터 구성 추가 ] - 추후, email 을 이용해 데이터를 걸러낼것이므로

        {
            id: createEventId(),        // 이건 고정시키고
            title: "All-day event",     // "타이틀"
            start: todayStr,            // 이건 시간
            email: "test@test.com",     // 사용자 이메일을 추가시켜서 추후, 필터되게 만들자.
        },


3. 캘린더의 값 DB에 넣어보자 

    < helper / calendar-add-to-DB>

        export type PostType = {
            title: string;
            start: string;
            email: string;
        };
        
        export const addCalendarToDb = async (exerciseData: PostType) => {
            await fetch(
            "https://do-health-project-default-rtdb.firebaseio.com/user/calendar.json",
            {
                method: "POST",
                body: JSON.stringify(exerciseData),
                headers: {
                "Content-Type": "application/json",
                },
            }
            );
        };
        
    <components / fullcalendar / calendar.tsx >

        import { addCalendarToDb } from "../helper/calendar-add-to-DB"; // 내가 넣은 DB에 넣을 함수
                        ...

        handleDateSelect = (selectInfo: DateSelectArg) => {
            let title = prompt("Please enter a new title for your event");
            let calendarApi = selectInfo.view.calendar;
        
            calendarApi.unselect(); // clear date selection
            console.log(selectInfo);
        
            if (title) {
                calendarApi.addEvent({
                    id: createEventId(),
                    title,
                    start: selectInfo.startStr,
                    end: selectInfo.endStr,
                    allDay: selectInfo.allDay,
                });
        
                addCalendarToDb({       // 내가 넣은 DB에 넣을 함수
                    title,
                    start: selectInfo.startStr,
                    email: "test@test.com",
                });
            }
        };

4. 성공했다. DB 의 값을 가져와서, "리덕스스토어"에 넣어본다. 

    < store/calendar-slice.tsx >

            import { createSlice, PayloadAction } from "@reduxjs/toolkit";

            export interface PostCalendarType {
                title: string;
                start: string;
                email: string;
            }

            const initialState: { calendarData: PostCalendarType[] } = {
                calendarData: [],
            };

            const calendarSlice = createSlice({
                name: "calendar",
                initialState,
                reducers: {
                    updateAllcalendar(state, action: PayloadAction<PostCalendarType[]>) {
                    state.calendarData = action.payload; // payload 에서 오는 값을, calendarData 로 교체할 것이다.
                    },
                },
            });

            export const calendarActions = calendarSlice.actions;

            export default calendarSlice.reducer;


    < store/calendar-actions.tsx >

            import { Dispatch } from "@reduxjs/toolkit";
            import { calendarActions } from "./calendar-slice";
            import { useDispatch } from "react-redux"; // useDispath 의 사전 생성
            import type { AppDispatch } from "../store/index"; //  action 생성자용 Dispatch 타입

            let eventGuid = 0;

            export function createEventId() {
                return String(eventGuid++);
            }

            export const sendRequest = () => {
                return async (dispatch: Dispatch) => {   // 타입은 Dispatch 이다.
                   
                    const fetchData = async () => {       // 비동기 함수 만들어서
                        const response = await fetch(
                            "https://do-health-project-default-rtdb.firebaseio.com/user/calendar.json"
                        );
                        const responseData = await response.json();

                        const refineData = [];              // 파이어 베이스에서 데이터 것 refine

                        for (const key in responseData) {
                            refineData.push({
                                id: createEventId(),
                                title: responseData[key].start,
                                start: responseData[key].title,
                                email: responseData[key].email,
                            });
                        }

                        return refineData;
                    };

                    const allCalendar = await fetchData();

                    dispatch(calendarActions.updateAllcalendar(allCalendar)); // inputData를 집어넣는 action 을 한다.
                };
            };

            //  Thunk action 생성자를 만들때, 타입을 지정하기
            //  https://redux.js.org/tutorials/typescript-quick-start#define-typed-hooks

            export const useAppDispatch: () => AppDispatch = useDispatch;

    < store / index.tsx>

            import { configureStore } from "@reduxjs/toolkit";
            import calendarSlice from "./calendar-slice";

            export const store = configureStore({
                reducer: {
                    calendar: calendarSlice,
                },
            });

            export type RootState = ReturnType<typeof store.getState>;
            export type AppDispatch = typeof store.dispatch;


5. 아이디별로, 달력의 초기값을 뽑아, 달력의 초기값을 만들어보자.

    ** 클래스 형으로 정의되어, useSelector 를 사용 할 수 없다.
    ** App.js 에서 useSelector 를 통해 받은 후, props 로, 클래스의 fullcalendar 로 넘겨주자.

    < App.tsx >     // DB 값 받아온다.

            import { Route, Switch } from "react-router-dom";
            import { useEffect } from "react";

            import Calendar from "./fullcalendar/calendar";

            import { sendRequest as sendRequestForCalendars, useAppDispatch } from "./store/calendar-action";

            function App() {
                const calendarData = useSelector(           // 캘린더 값 넘겨받기
                    (state: RootState) => state.calendar.calendarData
                  );

                const dispatch = useAppDispatch();

                useEffect(() => {
                    dispatch(sendRequestForCalendars());
                }, [dispatch]);

                return (
                    <div className="App">
                        <Switch>
                                ...
                            <Route path={"/calendar"}>
                                <Calendar calendarData={calendarData} />        // 값 넘겨주기
                            </Route>

    < fullcalendar / calendar.tsx >

                        ...

        interface DemoAppState {
            weekendsVisible: boolean;
            currentEvents: EventApi[];
        }
        
        interface Props {
            calendarData: { title: string; start: string; email: string }[];    // Props type 지정후
        }
        
        export default class Calendar extends React.Component<Props, {}, DemoAppState> {    // Props 타입을 등록하고
            state: DemoAppState = {
                weekendsVisible: true,
                currentEvents: [],
            };
        
            render() {
                const { calendarData } = this.props;        // 값을 받아온다.
            
                return (
                    <div className="demo-app">
                    {this.renderSidebar()}
                    <div className="demo-app-main">
                        <FullCalendar
                        plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin]}

                        ...
               
                        initialEvents={calendarData} // 넣어봤는데, 잠깐 뜨고, 유지가 안된다.
                        select={this.handleDateSelect}
                 

    < 오류발생>
        데이터를 넣었지만, 잠깐 뜨고, 유지가 되지 않는다.

    < 이유 >

        API 에서 강제로, INITIAL_EVETNT 를 초기값으로 고정시킨다.

6. DOCS 에서 하란 대로, INITIAL_EVETNT 를 제거하고, evnets 옵션을 통해 스토어의 값을 집어넣는다.

        ** initialEvents 옵션을 제거하고, events 옵션으로 변경
            
        return (
            <div className="demo-app">
            {this.renderSidebar()}
            <div className="demo-app-main">
                <FullCalendar
                plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin]}
                                ...

                events={data}           // [바로 여기를 event 로 교체] alternatively, use the `events` setting to fetch from a feed
                select={this.handleDateSelect}

7. 최종 마무리 : 데이터를 가져오고 나서, "로그인 되어있다면", "email Id" 에 맞는 값을 필터한 후에, 그 값을 캘린더에 넣도록 한다.[최종]
    
        < App.tsx >

            import { useCookies } from "react-cookie";

            function App() {
                const [cookies] = useCookies(["auth-cookie"]);      // 로그인 쿠키
                const history = useHistory();

                const calendarData = useSelector(                   // 캘린더 값 넘겨받기
                    (state: RootState) => state.calendar.calendarData
                );
               
                let filteredCalendar: PostCalendarType[] = [];      //캘린더 값 필터하기

                if (cookies["auth-cookie"]) {
                    filteredCalendar = calendarData.filter(         // 로그인한 아이디로, 켈린더 데이터 뽑기
                        (data) => data.email === cookies["auth-cookie"].email
                    );
                }
              
                const getOut = () => {                              // 넘겨줄 getOut함수 만들기
                    history.replace("/");
                };

                const dispatch = useAppDispatch();

                useEffect(() => {
                    dispatch(sendRequestForCalendars());            // 캘린더 값 dispatch 함수
                }, [dispatch]);

                return (
                    <div className="App">
                        <Switch>
                            <Route path={"/calendar"}>
                                <Calendar
                                    calendarData={filteredCalendar}
                                    getOut={getOut}
                                    isLogedIn={cookies["auth-cookie"]}    // 로그인 했는지 확인
                                />
                            </Route>



        <components / fullcalendar / calendar.tsx >

            import { addCalendarToDb } from "../helper/calendar-add-to-DB"; // 내가 넣은 DB에 넣을 함수

                            ...

            interface Props {
                calendarData: { title: string; start: string; email: string }[];    // 넘겨받을 값 Type 지정
                getOut: () => void;
                isLogedIn: string;
            }

            export default class Calendar extends React.Component<Props, {}, DemoAppState> {    // 타입 넣고
                state: DemoAppState = {
                    weekendsVisible: true,
                    currentEvents: [],
                };

                render() {
                    const calendarData = this.props.calendarData;       // 뽑아서 사용
                    const getOut = this.props.getOut;
                    const isLogedIn = this.props.isLogedIn;

                    if (!isLogedIn) {                           // 로그인 안하면 아웃
                        getOut();
                    }

                    return (
                        <div className="demo-app">
                            {this.renderSidebar()}
                            <div className="demo-app-main">
                                <FullCalendar
                                            ...
                                    events={calendarData}       // 캘린더 데이터 넣기
                                    select={this.handleDateSelect}



    ** [적절한 스타일링 추가, 필요없는 코드 제거] - 사이드바는 제거했다.

8. 삭제 하게 만들기

    1) FireBase 의 Delete Method 

        "중첩된 아이디의 주소로 접근해서 DELETE method를 사용하기만 하면 된다."
        ** 그러므로, "SDFC23dfgCD" 따위의 "DB가 만드는 자동 생성 id" 도, fetch 를 할때 가져와야 하겠다.

        ** 

    2) calendar 내에서, event 의 값 delete 하려 했을 때 가져오기
                        
        : console.log(clickInfo.event) 에 접근해서, 안에 있는 데이터를 알아보았다.
        후에, 필요한 값을 뺀 것이 아래에 있는 것들이다.

            handleEventClick = (clickInfo: EventClickArg) => {
                if (
                window.confirm(
                    // window 를 앞에 붙였다.
                    `Are you sure you want to delete the event '${clickInfo.event.title}'`
                )
                ) {
                clickInfo.event.remove();
                console.log(clickInfo.event._def.publicId);         // 지정했을때 Id (1,2...하면서 올라가는)
                console.log(clickInfo.event.extendedProps.email);   // 작성자 email
                }
            };

    3) fetch 를 해서 GET 할때, firebaseid 도 가져오기

        < store / calendar-action.tsx >

            export const sendRequest = () => {
                return async (dispatch: Dispatch) => {      // 타입은 Dispatch 이다.         

                    const fetchData = async () => {            // 비동기 함수 만들어서
    
                        const response = await fetch(
                            "https://do-health-project-default-rtdb.firebaseio.com/user/calendar.json"
                        );
                        const responseData = await response.json();

                        const refineData = [];                  // 파이어 베이스에서 데이터 것 refine

                        for (const key in responseData) {
                            refineData.push({
                                firebaseid:key,                     // 추가적으로 firebaseid 를 가져온다. (삭제용)
                                id: createEventId(),
                                title: responseData[key].title,
                                start: responseData[key].start,
                                email: responseData[key].email,
                            });
                        }
                        
    4) [ 1단계 - 초기화] 캘린더 내에서, 정보를 담을 State를 사용하기 위한 초기화하기


            import { addCalendarToDb } from "../helper/calendar-add-to-DB"; // 내가 넣은 DB에 넣을 함수

            interface DemoAppState {
                weekendsVisible: boolean;
                currentEvents: EventApi[];
                textid: string;             // 미리 state의 type 을 등록
                email: string;              // 미리 state의 type 을 등록
            }

            interface Props {
                calendarData: { title: string; start: string; email: string }[];
                getOut: () => void;
                isLogedIn: string;
                dataFromCalendarForDelete: (id: string, email: string) => void;
            }

            export default class Calendar extends React.Component<Props, {}, DemoAppState> {
                state: DemoAppState = {
                    weekendsVisible: true,
                    currentEvents: [],
                    textid: "",             // state 사용을 위한 초기화
                    email: "",              // state 사용을 위한 초기화
            };

            render() {
                const calendarData = this.props.calendarData;


    5) [ 2단계 - 기존에 있는 delete 함수에서, State값 변경시키기 ] "캘린더 내에서, delete 버튼을 누르면", "캘린더의 State" 에 업데이트, 후에, App.tsx 로 넘기기

        < 캘린더의 이벤트 클릭 핸들러에, state를 업데이트 하게 한다.>

            handleEventClick = (clickInfo: EventClickArg) => {
                if (
                    window.confirm(       // window 를 앞에 붙였다.
                        `Are you sure you want to delete the event '${clickInfo.event.title}'`
                )
                ) {
                clickInfo.event.remove();
                this.setState({                             // delete 를 하면, State를 업데이트한다.
                    textid: clickInfo.event._def.publicId,
                    email: clickInfo.event.extendedProps.email,
                });
                }
            };

        ===========================================
        < 캘린더의 업데이트된 State와, App.tsx 에서 온 상향식 props 를 위한 함수로, App.tsx 로 값을 넘긴다.>

            interface Props {
                calendarData: { title: string; start: string; email: string }[];
                getOut: () => void;
                isLogedIn: string;
                dataFromCalendarForDelete: (id: string, email: string) => void;         // App.tsx 에서 상향식 props 를 위해 함수를 넘겨준다.
            }
            
            export default class Calendar extends React.Component<Props, {}, DemoAppState> {
                state: DemoAppState = {
                weekendsVisible: true,
                currentEvents: [],
                textid: "",                 // state 사용을 위한 초기화
                email: "",                  // state 사용을 위한 초기화
            };
          
                render() {
                    const calendarData = this.props.calendarData;
                    const getOut = this.props.getOut;
                    const isLogedIn = this.props.isLogedIn;
                    const dataFromCalendarForDelete = this.props.dataFromCalendarForDelete;
                    const { textid, email } = this.state;                   // delete 버튼을 누르면, state 를 받아온다.
                
                    if (!isLogedIn) {
                        getOut();
                    }
                
                    if (textid) {
                        dataFromCalendarForDelete(textid, email);   // App.tsx 로 넘긴다. (App.tsx 에서 넘어온 상향식 Props 를 위한 함수)
                        this.setState({
                            textid: "",                     // 초기화 [ X 안된다 - render 안에서는, state 변경 불가랜다.]
                            email: "",                      // 초기화 [ X 안된다 - render 안에서는, state 변경 불가랜다.]
                        });
                    }
                
                    return (
                    <div className="demo-app">
                        <div className="demo-app-main">



            ** render 안에서, 직접 변경은 불가능하니, 함수형으로 만들어서, State 를 초기화시킨다.

                    if (textid) {
                        dataFromCalendarForDelete(textid, email);   // App.tsx 로 넘긴다. (App.tsx 에서 넘어온 상향식 Props 를 위한 함수)
                        this.initializeState()
                    }

                    ====================
            
                    initializeState = () => {
                        this.setState({ textid:"", email:"" })
                    };

            *** 이것도 안된다. 그냥 render 안에서, "순수함수 이외의 함수" 를 사용하는 것은 불가능하다.

                "일단 초기화는 포기한다."


    6) [ 3단계 - App.tsx 에서, 캘린더로부터 온 값을 가지고, firebaseid 알아내고, 삭제하기 ] 

        <helper 함수를 생성한다>

            export const removeCalendarToDb = async (firebaseid: string) => {
                await fetch(
                    `https://do-health-project-default-rtdb.firebaseio.com/user/calendar/${firebaseid}.json`,
                    {
                        method: "DELETE",
                    }
                );
            };
        
            ==> firebase는 "id 가 곧, 주소"이기 때문에, 주소의 끝단에, id 를 붙여놓고, Delete method 만 사용하면 된다.
                
        <App.tsx 에서, 캘린더로부터 넘겨받은 값을 가지고, Data 를 뒤져, 맞는 firebaseId를 찾아낸다.>

             
                const dataFromCalendarForDelete = (id: string, email: string) => {     // 캘린더 안의 delete 하기 위한 값 넘겨받기, 삭제하기
                    const selectedFirebaseData = calendarData.find(
                        (item) => item.id === id && item.email === email
                    );
                
                    if (selectedFirebaseData !== undefined) {
                        const selectedFirebaseId = selectedFirebaseData.firebaseid;
                
                        removeCalendarToDb(selectedFirebaseId);
                    }
                };

        ** store 의 Slice 에서, 새 타입을 지정하는 것을 잊지 말자. firebaseid:string이라던가... (기존에는 등록해 놓지 않은 타입이 많다.)


    <최종 배운점>

        1. 클래스의 상향식 props 의 사용

            1) 상위컴포넌트(App.tsx) 로 부터 하위 컴포넌트(클래스형) 으로 함수를 넘긴다.
            2) 클래스 컴포넌트에서는, interface Props {} 로, 넘겨받을 함수의 타입을 지정한다.

            3) 클래스의 interface xxxAppState {} 를 통해, State 로 사용할 타입을 정의한다.

            3) 클래스의 메인클래스( export default class Calendar extends ...으로 시작하는) 
                안의 state: ... = {} 를 통해, state를 초기화한다.

            4) 클래스의 this.setState() 를 통해, state 에 값을 넣는다. 이때, render 보단 밖에서, 함수를 정의하고, 함수를 사용하는 형태로 state 를 넣는다.
            5) 클래스의 render(){} 안쪽에서, App.tsx 로부터 넘겨받은 함수를 사용한다. state 의 값과 함께

                * 넘겨받은 props 를 사용하려면, 반드시, render 함수 안에서 사용해야하고(컴포넌트함수처럼)
                * 클래스에서는 값을 사용하려면, useState 처럼, state 를 반드시 사용해야한다.

        이런 형식이다.
        
            interface DemoAppState {            // state 로 사용할 것의 타입들
                weekendsVisible: boolean;
                currentEvents: EventApi[];
                textid: string; // 미리 state의 type 을 등록
                email: string; // 미리 state의 type 을 등록
                useEmail: string;
            }
            
            interface Props {                   // Props 로 넘겨받을 값들의 타입들
                calendarData: { title: string; start: string; email: string }[];
                getOut: () => void;
                isLogedIn: { idToken: string; email: string };
                dataFromCalendarForDelete: (id: string, email: string) => void;
            }
            
            export default class Calendar extends React.Component<Props, {}, DemoAppState> {    // state 와, Props 등, 타입을 전부 넣는다.
                state: DemoAppState = {     // state 의 초기화
                    weekendsVisible: true,
                    currentEvents: [],
                    textid: "",                         // state 사용을 위한 초기화
                    email: "",                          // state 사용을 위한 초기화
                    useEmail: this.props.isLogedIn.email,
                };
  
            







32. [ 지도 API ] 를 이용하여, "근처의 헬스장 찾기" 를 만들어본다.


                

                